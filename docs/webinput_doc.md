# WebInput Module

## Goals

### Current Focus: Mouse and Keyboard
The `webinput` module currently provides a streamlined interface for handling mouse (position, buttons, wheel) and keyboard events within a Zig WebAssembly application. It relies on JavaScript event listeners forwarding data to exported Zig functions, which then update an internal state that can be polled by the application.

### Future Enhancements: Gamepad Support
Gamepad support was initially drafted but has been temporarily removed to simplify the core module. The necessary Zig FFI declarations and JavaScript glue code have been preserved below and are planned for future integration. This will allow polling for connected gamepads, their button states, and axis values.

## Using `webinput` (Mouse & Keyboard)

### Overview
The `webinput` module allows your Zig Wasm application to track mouse and keyboard states.
- **JavaScript Side (`js/webinput.js`):**
    - A `setupInputSystem(wasmInstanceExports, canvasElementOrId)` function initializes the system.
    - It attaches event listeners to the specified HTML canvas for mouse events (move, down, up, wheel). Mouse coordinates are relative to the canvas.
    - It attaches event listeners to the `window` object for keyboard events (keydown, keyup).
    - These listeners call exported functions from your Zig Wasm module (e.g., `zig_internal_on_mouse_move`).
- **Zig Side (`src/webinput.zig`):**
    - Stores the current and previous state for mouse (position, buttons, wheel delta) and keyboard (key states).
    - Provides internal exported functions (e.g., `zig_internal_on_mouse_move`) that are called by the JavaScript event listeners to update the state.
    - Offers a public API for your Zig application to:
        1. Call `update_input_frame_start()` at the beginning of each frame. This updates previous states (for "just pressed/released" logic) and resets per-frame accumulators (like mouse wheel delta).
        2. Query the current input state using functions like `get_mouse_position()`, `is_mouse_button_down()`, `was_key_just_pressed()`, etc.

### Zig Setup (`src/webinput.zig`)

The Zig module maintains internal state and exposes functions for JS to call and for your app to query.

**Key Zig Structures (Internal):**
- `MouseState`: Stores `x`, `y`, `buttons_down`, `prev_buttons_down`, `wheel_delta_x`, `wheel_delta_y`.
- `KeyboardState`: Stores `keys_down`, `prev_keys_down` (arrays indexed by key codes).

**Exported Zig Functions (called by JavaScript):**
These functions are `pub export` in `src/webinput.zig` and are called by the event listeners in `js/webinput.js`.
- `zig_internal_on_mouse_move(x: f32, y: f32) void`
- `zig_internal_on_mouse_button(button_code: u32, is_down: bool, x: f32, y: f32) void`
- `zig_internal_on_mouse_wheel(delta_x: f32, delta_y: f32) void`
- `zig_internal_on_key_event(key_code: u32, is_down: bool) void`

**Public Zig API (called by your application):**
- `update_input_frame_start() void`: Call once at the start of your game loop/update.
- `get_mouse_position() MousePosition`: Returns `{ .x: f32, .y: f32 }`.
- `is_mouse_button_down(button_code: u32) bool`
- `was_mouse_button_just_pressed(button_code: u32) bool`
- `was_mouse_button_just_released(button_code: u32) bool`
- `get_mouse_wheel_delta() MouseWheelDelta`: Returns `{ .dx: f32, .dy: f32 }`.
- `is_key_down(key_code: u32) bool`
- `was_key_just_pressed(key_code: u32) bool`
- `was_key_just_released(key_code: u32) bool`

*(Note: `button_code` for mouse typically follows `event.button`: 0 for left, 1 for middle, 2 for right. `key_code` corresponds to `event.keyCode`.)*

### JavaScript Setup (`js/webinput.js`)

The primary JavaScript component is the `setupInputSystem` function.

- **`export function setupInputSystem(instanceExports, canvasElementOrId)`**:
    - `instanceExports`: The `exports` object from your instantiated Wasm module.
    - `canvasElementOrId`: Either the HTML canvas element itself or its string ID. Mouse events are bound to this canvas. If not provided or not found, mouse input will be unavailable (a warning will be logged). Keyboard input is global (attached to `window`).

This function must be called after your Wasm module is instantiated.

### Project Integration

**1. `build.zig` and `main.js` Generation:**

Since `js/webinput.js` (for mouse/keyboard) does not export functions that Zig needs to *import* via the `env` object, you don't need to add specific FFI import entries for it in your `main.js`'s `imports.env` object.

However, your `main.js` (often generated by `build.zig`) needs to:
1.  Import `setupInputSystem` from your `webinput.js` file.
2.  Call `setupInputSystem` after the Wasm module is instantiated, passing the Wasm instance's exports and the canvas element/ID.

**Example `main.js` structure (conceptual):**

```javascript
// main.js (likely generated or influenced by build.zig)

// Import from the webinput.js file that will be copied to your dist/ directory
import { setupInputSystem } from './webinput.js'; 

async function initWasm() {
    const imports_obj = {
        env: {
            // ... any other FFI imports your app needs from other modules ...
        }
    };

    const { instance } = await WebAssembly.instantiateStreaming(fetch('app.wasm'), imports_obj);

    // Initialize the input system AFTER Wasm instantiation
    // 'canvas' should be the ID of your <canvas> element in index.html
    setupInputSystem(instance.exports, 'canvas'); 

    // Call your Zig application's main function (if it has one)
    if (instance.exports.main) {
        instance.exports.main();
    }
    
    // Start your render loop or application logic
    // e.g., requestAnimationFrame(gameLoop); 
    // where gameLoop calls instance.exports.zig_render_frame() or similar
}

initWasm().catch(console.error);
```

Your `build.zig` should ensure `webinput.js` is copied to the output directory (e.g., `dist/`) if it's listed as a used API. The part of `build.zig` that generates `main.js` would then need to include the import statement for `setupInputSystem` and the call to it.

**Example `build.zig` modification for `main.js` (simplified):**

If `webinput` is a "used API", you might add a step to inject the `setupInputSystem` call into your generated `main.js`.

```zig
// In build.zig, when generating main.js, after wasm instantiation:
// This is a conceptual addition to the main_js string generation.

// ... (after WebAssembly.instantiateStreaming) ...
var main_js_content = std.ArrayList(u8).init(b.allocator);
defer main_js_content.deinit();
const writer = main_js_content.writer();

// ... (existing main.js generation for imports and instantiation) ...

// Add setupInputSystem call if webinput is used
var webinput_used = false;
for (used_apis) |api_name| {
    if (std.mem.eql(u8, api_name, "webinput")) {
        webinput_used = true;
        break;
    }
}

if (webinput_used) {
    try writer.print(
        \\import {{ setupInputSystem }} from './webinput.js';
        \\
    , .{});
}

// ... (rest of the instantiation code) ...
try writer.print(
    \\const {{ instance }} = await WebAssembly.instantiateStreaming(fetch('app.wasm'), imports_obj);
    \\
, .{});

if (webinput_used) {
    try writer.print(
        \\setupInputSystem(instance.exports, 'canvas'); // Assumes canvas ID is 'canvas'
        \\
    , .{});
}

try writer.print(
    \\if (instance.exports.main) {{ instance.exports.main(); }}
    \\init().catch(console.error);
, .{});

// Then use main_js_content.items to write the main.js file.
```

**2. Example Zig Application Usage (`src/main.zig`):**

```zig
const webinput = @import("zig-wasm-ffi").webinput; // Adjust import path as per your module setup

// Example key codes (refer to JavaScript event.keyCode values)
const KEY_SPACE = 32;
const KEY_W = 87;
const KEY_A = 65;
const KEY_S = 83;
const KEY_D = 68;

// This would typically be your main game loop function exported to JS,
// or called after wasm initialization.
pub export fn update_and_render_frame(dt: f32) void {
    _ = dt; // Unused for this example

    // 1. Update input state at the beginning of the frame
    webinput.update_input_frame_start();

    // 2. Query mouse state
    const mouse_pos = webinput.get_mouse_position();
    // log.debug("Mouse: x={d:.1}, y={d:.1}", .{ mouse_pos.x, mouse_pos.y });

    if (webinput.was_mouse_button_just_pressed(0)) { // Left mouse button
        // log.debug("Left mouse button just pressed!", .{});
    }
    if (webinput.is_mouse_button_down(0)) {
        // log.debug("Left mouse button is down.", .{});
    }

    const wheel = webinput.get_mouse_wheel_delta();
    if (wheel.dx != 0 or wheel.dy != 0) {
        // log.debug("Mouse wheel: dx={d:.1}, dy={d:.1}", .{ wheel.dx, wheel.dy });
    }

    // 3. Query keyboard state
    if (webinput.was_key_just_pressed(KEY_SPACE)) {
        // log.debug("Spacebar just pressed!", .{});
    }
    if (webinput.is_key_down(KEY_W)) {
        // log.debug("W key is down (forward).", .{});
    }
    if (webinput.is_key_down(KEY_A)) {
        // log.debug("A key is down (left).", .{});
    }
    // ... and so on for other keys ...

    // ... rest of your game logic and rendering ...
}

// If you have a main function called once at startup:
// pub fn main() !void {
// log.debug("Zig main started. Input system should be set up by JS.", .{});
// }
```

## Future Gamepad Support (Preserved Code)

The following code snippets were part of the initial gamepad implementation and are preserved here for future reference and integration.

### Zig (`src/webinput.zig` - Gamepad Snippets)

```zig
// --- Configuration Constants (for Gamepads) ---
// const MAX_GAMEPADS: usize = 4;
// const MAX_GAMEPAD_BUTTONS: usize = 16;
// const MAX_GAMEPAD_AXES: usize = 4;

// --- Gamepad State (Opaque Type) ---
// pub const Gamepad = opaque {}; // May not be needed if JS marshals all data

// --- FFI Declarations for JavaScript Gamepad Glue ---
// pub extern "env" fn platform_poll_gamepads() void;
// pub extern "env" fn platform_get_gamepad_count() u32;
// pub extern "env" fn platform_is_gamepad_connected(pad_index: u32) bool;
// pub extern "env" fn platform_get_gamepad_buttons(
//     pad_index: u32,
//     out_buttons_ptr: [*c]bool, // Expects a C-style boolean array (u8 in practice from JS)
//     buttons_array_len: u32,
// ) u32; // Returns number of buttons written
// pub extern "env" fn platform_get_gamepad_axes(
//     pad_index: u32,
//     out_axes_ptr: [*c]f32,
//     axes_array_len: u32,
// ) u32; // Returns number of axes written

// --- In update_input_frame_start() ---
// // Tell JavaScript to poll gamepads for this frame
// platform_poll_gamepads();

// --- Public Gamepad Getters ---
// pub fn get_gamepad_count() u32 {
//     return platform_get_gamepad_count();
// }
//
// pub fn is_gamepad_connected(pad_index: u32) bool {
//     if (pad_index < MAX_GAMEPADS) {
//         return platform_is_gamepad_connected(pad_index);
//     }
//     return false;
// }
//
// pub const GamepadData = struct {
//     buttons: [MAX_GAMEPAD_BUTTONS]bool = [_]bool{false} ** MAX_GAMEPAD_BUTTONS,
//     axes: [MAX_GAMEPAD_AXES]f32 = [_]f32{0.0} ** MAX_GAMEPAD_AXES,
//     is_connected: bool = false,
// };
//
// pub fn get_gamepad_state(pad_index: u32) GamepadData {
//     var data: GamepadData = .{};
//     if (pad_index >= MAX_GAMEPADS) return data;
//
//     data.is_connected = platform_is_gamepad_connected(pad_index);
//     if (!data.is_connected) return data;
//
//     // Ensure compatible pointers for C-style bool array (u8 in practice from JS)
//     var raw_buttons: [MAX_GAMEPAD_BUTTONS]u8 = [_]u8{0} ** MAX_GAMEPAD_BUTTONS;
//     _ = platform_get_gamepad_buttons(pad_index, @ptrCast(&raw_buttons), MAX_GAMEPAD_BUTTONS);
//     for (0..MAX_GAMEPAD_BUTTONS) |i| {
//         data.buttons[i] = (raw_buttons[i] != 0);
//     }
//
//     _ = platform_get_gamepad_axes(pad_index, @ptrCast(&data.axes), MAX_GAMEPAD_AXES);
//
//     return data;
// }
```

### JavaScript (`js/webinput.js` - Gamepad Snippets)

```javascript
// // --- Configuration (align with Zig's MAX_GAMEPADS, etc. if needed for JS logic) ---
// const ZIG_MAX_GAMEPADS = 4;
// const ZIG_MAX_GAMEPAD_BUTTONS = 16;
// const ZIG_MAX_GAMEPAD_AXES = 4;

// // --- Wasm Memory Buffer (needed for writing gamepad data directly) ---
// let wasmMemoryBuffer = null; 
// // In setupInputSystem:
// // if (wasmExports.memory) {
// //     wasmMemoryBuffer = wasmExports.memory.buffer;
// // } else {
// //     console.error("WebInput: Wasm memory not found in exports. Gamepad functions that write to Wasm memory will fail.");
// // }


// // --- Gamepad State Cache ---
// let gamepads_cache = []; // Stores simplified gamepad states from navigator.getGamepads()

// // --- Gamepad FFI Functions (Called by Zig, exported by JS) ---

// export function platform_poll_gamepads() {
//     if (!navigator.getGamepads) {
//         gamepads_cache = [];
//         return;
//     }
//     const rawGamepads = navigator.getGamepads();
//     const new_cache = [];
//     for (let i = 0; i < rawGamepads.length && i < ZIG_MAX_GAMEPADS; i++) {
//         const pad = rawGamepads[i];
//         if (pad) {
//             const buttons = [];
//             for(let b_idx = 0; b_idx < pad.buttons.length && b_idx < ZIG_MAX_GAMEPAD_BUTTONS; b_idx++) {
//                 buttons.push(pad.buttons[b_idx].pressed);
//             }
//             const axes = [];
//             for(let a_idx = 0; a_idx < pad.axes.length && a_idx < ZIG_MAX_GAMEPAD_AXES; a_idx++) {
//                 axes.push(pad.axes[a_idx]);
//             }
//             new_cache[i] = {
//                 connected: pad.connected,
//                 id: pad.id,
//                 buttons: buttons, // array of booleans
//                 axes: axes,       // array of floats
//             };
//         } else {
//             new_cache[i] = null;
//         }
//     }
//     gamepads_cache = new_cache;
// }

// export function platform_get_gamepad_count() {
//     // Returns the number of "slots" polled, up to ZIG_MAX_GAMEPADS.
//     // Some slots might be null (disconnected).
//     return gamepads_cache.length; 
// }

// export function platform_is_gamepad_connected(pad_index) {
//     if (pad_index < gamepads_cache.length && gamepads_cache[pad_index]) {
//         return gamepads_cache[pad_index].connected;
//     }
//     return false;
// }

// export function platform_get_gamepad_buttons(
//     pad_index,
//     out_buttons_ptr, // u32 address in Wasm memory for a bool/u8 array
//     buttons_array_len // Max buttons to write (should match ZIG_MAX_GAMEPAD_BUTTONS from Zig)
// ) {
//     if (!wasmMemoryBuffer) return 0; // Wasm memory is required
//     if (pad_index >= gamepads_cache.length || !gamepads_cache[pad_index] || !gamepads_cache[pad_index].connected) {
//         return 0; // No gamepad data or not connected
//     }

//     const pad_info = gamepads_cache[pad_index];
//     // Create a Uint8Array view into Wasm memory. Zig expects bools, which are u8 in this context.
//     const wasm_buttons_view = new Uint8Array(wasmMemoryBuffer, out_buttons_ptr, buttons_array_len);
    
//     let buttons_written = 0;
//     for (let i = 0; i < pad_info.buttons.length && i < buttons_array_len; i++) {
//         wasm_buttons_view[i] = pad_info.buttons[i] ? 1 : 0; // Write 1 for true, 0 for false
//         buttons_written++;
//     }
//     // Zero out remaining buttons in the Zig array if the actual gamepad has fewer buttons
//     for (let i = buttons_written; i < buttons_array_len; i++) {
//         wasm_buttons_view[i] = 0;
//     }
//     return buttons_written; // Return the number of button states actually processed from the gamepad
// }

// export function platform_get_gamepad_axes(
//     pad_index,
//     out_axes_ptr, // u32 address in Wasm memory for an f32 array
//     axes_array_len // Max axes to write (should match ZIG_MAX_GAMEPAD_AXES from Zig)
// ) {
//     if (!wasmMemoryBuffer) return 0; // Wasm memory is required
//     if (pad_index >= gamepads_cache.length || !gamepads_cache[pad_index] || !gamepads_cache[pad_index].connected) {
//         return 0; // No gamepad data or not connected
//     }

//     const pad_info = gamepads_cache[pad_index];
//     // Create a Float32Array view into Wasm memory
//     const wasm_axes_view = new Float32Array(wasmMemoryBuffer, out_axes_ptr, axes_array_len);

//     let axes_written = 0;
//     for (let i = 0; i < pad_info.axes.length && i < axes_array_len; i++) {
//         wasm_axes_view[i] = pad_info.axes[i];
//         axes_written++;
//     }
//     // Zero out remaining axes in the Zig array if the actual gamepad has fewer axes
//     for (let i = axes_written; i < axes_array_len; i++) {
//         wasm_axes_view[i] = 0.0;
//     }
//     return axes_written; // Return the number of axis states actually processed from the gamepad
// }
```

This documentation should provide a good starting point for using the `webinput` module and for reintegrating gamepad support in the future.
